// Copyright 2018 NetApp, Inc. All Rights Reserved.

package utils

import (
	"context"
	"testing"
	"time"
)

var ctx = context.Background

// TestLockCreated tests that a lock is created when it is locked.
// It checks that the lock is not created when it is not locked.
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func TestLockCreated(t *testing.T) {
	Lock(ctx(), "testContext", "myLock")
	defer Unlock(ctx(), "testContext", "myLock")

	if _, ok := sharedLocks.lockMap["myLock"]; !ok {
		t.Error("Expected lock myLock to exist.")
	}

	if _, ok := sharedLocks.lockMap["myLock2"]; ok {
		t.Error("Did not expect lock myLock2 to exist.")
	}
}

// TestLockReused tests that the same lock is reused
// It checks that the lock is not created twice
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func TestLockReused(t *testing.T) {
	Lock(ctx(), "testContext", "reuseLock")
	Unlock(ctx(), "testContext", "reuseLock")

	lock1 := sharedLocks.lockMap["reuseLock"]

	Lock(ctx(), "testContext", "reuseLock")
	Unlock(ctx(), "testContext", "reuseLock")

	lock2 := sharedLocks.lockMap["reuseLock"]

	if lock1 != lock2 {
		t.Error("Expected locks to match.")
	}
}

// acquire1 acquires a lock and then releases it
// Parameters:
//    m1 - channel for commands
//    r - channel for results
// Returns:
//    none
// Example:
//    m1 := make(chan string, 3)
//    r := make(chan string)
//    go acquire1(m1, r)
//    m1 <- "lock"
//    m1 <- "unlock"
//    m1 <- "done"
//    <-r
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func acquire1(m1, r chan string) {
	for i := 0; i < 3; i++ {
		op := <-m1
		switch op {
		case "lock":
			Lock(ctx(), "testContext1", "behaviorLock")
		case "unlock":
			Unlock(ctx(), "testContext1", "behaviorLock")
		case "done":
			close(m1)
			r <- "done1"
			return
		}
	}
}

// acquire2 is a helper function for testing the behavior of the lock manager.
// It acquires a lock, then releases it, then acquires it again.
// Parameters:
//   m2: a channel for receiving commands from the test
//   r: a channel for sending a response to the test
// Returns:
//   nothing
// Example:
//   r := make(chan string)
//   m2 := make(chan string)
//   go acquire2(m2, r)
//   m2 <- "lock"
//   <-r
//   m2 <- "unlock"
//   <-r
//   m2 <- "lock"
//   <-r
//   m2 <- "done"
//   <-r
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func acquire2(m2, r chan string) {
	for i := 0; i < 3; i++ {
		op := <-m2
		switch op {
		case "lock":
			Lock(ctx(), "testContext2", "behaviorLock")
		case "unlock":
			Unlock(ctx(), "testContext2", "behaviorLock")
		case "done":
			close(m2)
			r <- "done2"
			return
		}
	}
}

// snooze is a no-op function that sleeps for 1 millisecond.
// It is used to prevent the scheduler from spinning too fast.
// Returns:
//    None
// Example:
//    snooze()
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func snooze() {
	time.Sleep(1 * time.Millisecond)
}

// TestLockBehavior tests the behavior of the Lock and Unlock methods.
// It is not a unit test, but rather a functional test.
// It checks that the lock is acquired by the first caller and that
// the second caller blocks until the first caller releases the lock.
// It also checks that the second caller can acquire the lock after
// the first caller releases it.
//
// -- Doc autogenerated on 2022-05-12 14:37:31.818596 --
func TestLockBehavior(t *testing.T) {
	r := make(chan string, 2)
	m1 := make(chan string, 3)
	m2 := make(chan string, 3)
	go acquire1(m1, r)
	go acquire2(m2, r)

	m2 <- "lock"
	snooze()
	m1 <- "lock"
	snooze()
	m2 <- "unlock"
	snooze()
	m1 <- "unlock"
	snooze()
	m2 <- "done"
	snooze()
	m1 <- "done"

	r1 := <-r
	r2 := <-r
	if r1 != "done2" && r2 != "done1" {
		t.Error("Expected done2 followed by done1.")
	}
}
