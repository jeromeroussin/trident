// Copyright 2022 NetApp, Inc. All Rights Reserved.

package utils

import (
	"errors"
	"fmt"
	"strings"
)

// ///////////////////////////////////////////////////////////////////////////
// bootstrapError
// ///////////////////////////////////////////////////////////////////////////

type bootstrapError struct {
	message string
}
// BootstrapError is a special error
// It returns a string with the error message
// and is used to indicate that Trident failed to initialize
// Parameters:
//   err - the error message
// Returns:
//   a bootstrapError
// Example:
//   err := utils.BootstrapError(errors.New("Something went wrong"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func BootstrapError(err error) error {
	return &bootstrapError{
		fmt.Sprintf("Trident initialization failed; %s", err.Error()),
	}
}

// IsBootstrapError returns true if the error is a bootstrap error
// Parameters:
//   err: error
// Returns:
//   true if the error is a bootstrap error
// Example:
//   if IsBootstrapError(err) {
//       // do stuff
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsBootstrapError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*bootstrapError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// foundError
// ///////////////////////////////////////////////////////////////////////////

type foundError struct {
	message string
}
// FoundError is an error
// It returns true for IsFoundError
// Parameters:
//    message - the error message
// Return:
//    error - the error
// Example:
//    err := FoundError("found")
//    if IsFoundError(err) {
//        // handle found error
//    }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func FoundError(message string) error {
	return &foundError{message}
}

// IsFoundError returns true if the error is a foundError
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a foundError, false otherwise
// Example:
//   isFound := utils.IsFoundError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsFoundError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*foundError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// notFoundError
// ///////////////////////////////////////////////////////////////////////////

type notFoundError struct {
	message string
}
// NotFoundError is a custom error
// It returns a 404 status code
// Parameters:
//    message - the message to return
// Returns:
//    error - the error
// Example:
//    err := NotFoundError("The requested volume does not exist")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func NotFoundError(message string) error {
	return &notFoundError{message}
}

// IsNotFoundError returns true if the error is a not found error
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a not found error
// Example:
//   if utils.IsNotFoundError(err) {
//       // handle error
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*notFoundError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// resourceNotFoundError - To identify external not found errors
// ///////////////////////////////////////////////////////////////////////////

// IsResourceNotFoundError returns true if the error is a resource not found error
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a resource not found error
// Example:
//   IsResourceNotFoundError(errors.New("Not Found"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsResourceNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	return strings.Contains(strings.ToLower(err.Error()), "not found")
}

// ///////////////////////////////////////////////////////////////////////////
// notReadyError
// ///////////////////////////////////////////////////////////////////////////

type notReadyError struct {
	message string
}
// NotReadyError is returned when Trident is initializing.
// It returns a string that can be used in an HTTP response.
// Returns:
//   *notReadyError
// Example:
//   if err := utils.NotReadyError(); err != nil {
//       return err
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func NotReadyError() error {
	return &notReadyError{
		"Trident is initializing, please try again later",
	}
}

// IsNotReadyError returns true if the error is a not ready error
// Parameters:
//   err - error to check
// Returns:
//   true if the error is a not ready error
// Example:
//   utils.IsNotReadyError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsNotReadyError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*notReadyError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedError struct {
	message string
}
// UnsupportedError is an error that indicates that a feature is not supported.
// It returns a string that can be used to display the error to the user.
// Parameters:
//    message - the error message
// Returns:
//    an error object
// Example:
//    err := utils.UnsupportedError("This feature is not supported")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func UnsupportedError(message string) error {
	return &unsupportedError{message}
}

// IsUnsupportedError returns true if the error is an unsupportedError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is an unsupportedError
// Example:
//   err := utils.UnsupportedError("test")
//   utils.IsUnsupportedError(err) // returns true
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsUnsupportedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// volumeCreatingError
// ///////////////////////////////////////////////////////////////////////////

type volumeCreatingError struct {
	message string
}
// VolumeCreatingError is an error
// It returns a message
// Parameters:
//    message string
// Returns:
//    error
// Example:
//    myError := utils.VolumeCreatingError("error message")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func VolumeCreatingError(message string) error {
	return &volumeCreatingError{message}
}

// IsVolumeCreatingError returns true if the error is a volumeCreatingError
// Parameters:
//    err - the error to check
// Return:
//    true if the error is a volumeCreatingError
// Example:
//    if IsVolumeCreatingError(err) {
//       // do something
//    }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsVolumeCreatingError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*volumeCreatingError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// volumeDeletingError
// ///////////////////////////////////////////////////////////////////////////

type volumeDeletingError struct {
	message string
}
// VolumeDeletingError is an error
// It returns the message
// Parameters:
//    message string
// Returns:
//    error
// Example:
//    err := utils.VolumeDeletingError("message")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func VolumeDeletingError(message string) error {
	return &volumeDeletingError{message}
}

// IsVolumeDeletingError returns true if the error is a volumeDeletingError
// Parameters:
//    err - the error to check
// Returns:
//    true if the error is a volumeDeletingError
// Example:
//    IsVolumeDeletingError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsVolumeDeletingError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*volumeDeletingError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// timeoutError
// ///////////////////////////////////////////////////////////////////////////

type timeoutError struct {
	message string
}
// TimeoutError is a custom error
// It returns a string message
// Parameters:
//    message string
// Return:
//    error
// Example:
//    err := utils.TimeoutError("My error message")
//    fmt.Println(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func TimeoutError(message string) error {
	return &timeoutError{message}
}

// IsTimeoutError returns true if the error is a timeout error
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a timeout error
// Example:
//   IsTimeoutError(errors.New("timeout"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsTimeoutError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*timeoutError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedKubernetesVersionError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedKubernetesVersionError struct {
	message string
}
// UnsupportedKubernetesVersionError is returned when the Kubernetes version is not supported
// It returns a string that can be used to display the error message
// Parameters:
//    err: the error message
// Returns:
//    error: the error message
// Example:
//    err := utils.UnsupportedKubernetesVersionError(err)
//    if err != nil {
//        return fmt.Errorf("%s", err)
//    }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func UnsupportedKubernetesVersionError(err error) error {
	return &unsupportedKubernetesVersionError{
		message: fmt.Sprintf("unsupported Kubernetes version; %s", err.Error()),
	}
}

// IsUnsupportedKubernetesVersionError returns true if the error is an unsupportedKubernetesVersionError
// Parameters:
//     err - the error to check
// Return:
//     true if the error is an unsupportedKubernetesVersionError, false otherwise
// Example:
//     if IsUnsupportedKubernetesVersionError(err) {
//         log.Error("Unsupported Kubernetes version")
//     }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsUnsupportedKubernetesVersionError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedKubernetesVersionError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileDeferredError
// ///////////////////////////////////////////////////////////////////////////

type reconcileDeferredError struct {
	message string
}
// ReconcileDeferredError is an error
// It returns a message and a boolean
// Parameters:
//    err - the error to return
// Returns:
//    the error
// Example:
//    err := utils.ReconcileDeferredError(errors.New("Some error"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func ReconcileDeferredError(err error) error {
	return &reconcileDeferredError{
		message: err.Error(),
	}
}

// IsReconcileDeferredError returns true if the error is a ReconcileDeferredError
// Parameters:
//     err - error to check
// Return:
//     true if the error is a ReconcileDeferredError, false otherwise
// Example:
//     if utils.IsReconcileDeferredError(err) {
//         // ...
//     }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsReconcileDeferredError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileDeferredError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileIncompleteError
// ///////////////////////////////////////////////////////////////////////////

type reconcileIncompleteError struct {
	message string
}
// ReconcileIncompleteError is an error that indicates that a reconciliation is not complete.
// It returns true for IsReconcileIncompleteError.
// Returns:
//   true
// Example:
//   if err := reconciler.Reconcile(request); err != nil && IsReconcileIncompleteError(err) {
//      return reconcile.Result{}, nil
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func ReconcileIncompleteError() error {
	return &reconcileIncompleteError{
		message: "reconcile incomplete",
	}
}

// ConvertToReconcileIncompleteError converts an error to a reconcileIncompleteError
// It returns the original error if it is already a reconcileIncompleteError
// Parameters:
//   err: the error to convert
// Returns:
//   the converted error
// Example:
//   reconcileIncompleteError := ConvertToReconcileIncompleteError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func ConvertToReconcileIncompleteError(err error) error {
	return &reconcileIncompleteError{
		message: err.Error(),
	}
}

// IsReconcileIncompleteError returns true if the error is a reconcileIncompleteError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a reconcileIncompleteError, false otherwise
// Example:
//   if IsReconcileIncompleteError(err) {
//       log.Errorf("reconcile error: %v", err)
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsReconcileIncompleteError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileIncompleteError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileFailedError
// ///////////////////////////////////////////////////////////////////////////

type reconcileFailedError struct {
	message string
}
// ReconcileFailedError is an error that is returned when a reconcile fails.
// It returns a message that includes the error that caused the reconcile to fail.
// Parameters:
//     err - the error that caused the reconcile to fail
// Returns:
//     a new error that includes the error that caused the reconcile to fail
// Example:
//     if err := r.Reconcile(request); err != nil {
//         return utils.ReconcileFailedError(err)
//     }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func ReconcileFailedError(err error) error {
	return &reconcileFailedError{
		message: fmt.Sprintf("reconcile failed; %s", err.Error()),
	}
}

// IsReconcileFailedError returns true if the error is a reconcileFailedError
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a reconcileFailedError
// Example:
//   _, err := utils.ReconcileFailedError()
//   if utils.IsReconcileFailedError(err) {
//     ...
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsReconcileFailedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileFailedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedConfigError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedConfigError struct {
	message string
}
// UnsupportedConfigError returns an error indicating that the provided configuration is not supported
// Parameters:
//    err - the error to wrap
// Returns:
//    an error indicating that the provided configuration is not supported
// Example:
//    err := utils.UnsupportedConfigError(errors.New("custom error message"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func UnsupportedConfigError(err error) error {
	return &unsupportedConfigError{
		message: fmt.Sprintf("unsupported configuration; %s", err.Error()),
	}
}

// IsUnsupportedConfigError returns true if the error is an unsupportedConfigError.
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an unsupportedConfigError
// Example:
//   if utils.IsUnsupportedConfigError(err) {
//       ...
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsUnsupportedConfigError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedConfigError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// tempOperatorError
// ///////////////////////////////////////////////////////////////////////////

type tempOperatorError struct {
	message string
}
// TempOperatorError returns a temporary operator error
// Parameters:
//   err - error
// Returns:
//   error
// Example:
//   err := TempOperatorError(err)
//   if err != nil {
//       panic(err)
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func TempOperatorError(err error) error {
	return &tempOperatorError{
		message: fmt.Sprintf("temporary operator error; %s", err.Error()),
	}
}

// IsTempOperatorError returns true if the error is a temporary operator error
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a temporary operator error
// Example:
//   found := utils.IsTempOperatorError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsTempOperatorError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*tempOperatorError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// invalidInputError
// ///////////////////////////////////////////////////////////////////////////

type invalidInputError struct {
	message string
}
// InvalidInputError is an error that is returned when the input is invalid.
// It returns a message that is useful to the user.
// Parameters:
//    message - the message to return
// Return:
//    an error object
// Example:
//    err := utils.InvalidInputError("The input is invalid")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func InvalidInputError(message string) error {
	return &invalidInputError{message}
}

// IsInvalidInputError returns true if the error is an invalid input error.
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an invalid input error, false otherwise
// Example:
//   IsInvalidInputError(errors.New("Invalid input"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsInvalidInputError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*invalidInputError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedCapacityRangeError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedCapacityRangeError struct {
	err     error
	message string
// UnsupportedCapacityRangeError is returned when the capacity range is not supported
// It returns the error message and the error
// Parameters:
//    err - the error message
// Return:
//    the error
// Example:
//    err := utils.UnsupportedCapacityRangeError(errors.New("capacity range is not supported"))
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func UnsupportedCapacityRangeError(err error) error {
	return &unsupportedCapacityRangeError{
		err, fmt.Sprintf("unsupported capacity range; %s",
			err.Error()),
	}
}

// HasUnsupportedCapacityRangeError returns true if the error is an unsupportedCapacityRangeError
// Parameters:
//   err: the error to check
// Returns:
//   bool: true if the error is an unsupportedCapacityRangeError
//   *unsupportedCapacityRangeError: the unsupportedCapacityRangeError if it is one, otherwise nil
// Example:
//   ok, unsupportedCapacityRangeError := utils.HasUnsupportedCapacityRangeError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func HasUnsupportedCapacityRangeError(err error) (bool, *unsupportedCapacityRangeError) {
	if err == nil {
		return false, nil
	}
	var unsupportedCapacityRangeErrorPtr *unsupportedCapacityRangeError
	ok := errors.As(err, &unsupportedCapacityRangeErrorPtr)
	return ok, unsupportedCapacityRangeErrorPtr
}

// ///////////////////////////////////////////////////////////////////////////
// maxLimitReachedError
// ///////////////////////////////////////////////////////////////////////////

type maxLimitReachedError struct {
	message string
}
// MaxLimitReachedError is returned when the maximum limit has been reached
// It returns a string message
// Parameters:
//    message - the message to return
// Returns:
//    the error
// Example:
//    err := utils.MaxLimitReachedError("Maximum size reached")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func MaxLimitReachedError(message string) error {
	return &maxLimitReachedError{message}
}

// IsMaxLimitReachedError returns true if the error is a maxLimitReachedError
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a maxLimitReachedError
// Example:
//   if utils.IsMaxLimitReachedError(err) {
//   	// handle error
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsMaxLimitReachedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*maxLimitReachedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// typeAssertionError
// ///////////////////////////////////////////////////////////////////////////

type typeAssertionError struct {
	assertion string
}

// Error types
// It returns a string representation of the error.
// Returns:
//   string representation of the error
// Example:
//   err := NewTypeAssertionError("this is the error")
//   fmt.Println(err.Error())
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func (e *typeAssertionError) Error() string {
	return fmt.Sprintf("could not perform assertion: %s", e.assertion)
}

// TypeAssertionError is a
// It returns a new error with the given assertion.
// Parameters:
//     assertion - the assertion that failed
// Returns:
//     a new error with the given assertion
// Example:
//     err := TypeAssertionError("assertion")
//     fmt.Println(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func TypeAssertionError(assertion string) error {
	return &typeAssertionError{assertion}
}

// ///////////////////////////////////////////////////////////////////////////
// authError
// ///////////////////////////////////////////////////////////////////////////

type authError struct {
	message string
}
// AuthError is an error
// It returns an error with a message
// Parameters:
//    message string
// Returns:
//    error
// Example:
//    err := AuthError("error message")
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func AuthError(message string) error {
	return &authError{message}
}

// IsAuthError returns true if the error is an auth error
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an auth error, false otherwise
// Example:
//   ok := IsAuthError(err)
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsAuthError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*authError)
	return ok
}

/////////////////////////////////////////////////////////////////////////////
// tooManyRequestsError (HTTP 429)
/////////////////////////////////////////////////////////////////////////////

type tooManyRequestsError struct {
	message string
}
// TooManyRequestsError is an error that indicates that the request was rejected due to rate limiting.
// It returns a 429 status code.
// Parameters:
//    message - the error message
// Returns:
//    an error
// Example:
//    if err := utils.TooManyRequestsError("Too many requests"); err != nil {
//       return err
//    }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func TooManyRequestsError(message string) error {
	return &tooManyRequestsError{message}
}

// IsTooManyRequestsError returns true if the error is a TooManyRequestsError
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a TooManyRequestsError
// Example:
//   err := utils.TooManyRequestsError("too many requests")
//   if utils.IsTooManyRequestsError(err) {
//       log.Println("too many requests")
//   }
//
// -- Doc autogenerated on 2022-05-12 14:18:50.293039 --
func IsTooManyRequestsError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*tooManyRequestsError)
	return ok
}
