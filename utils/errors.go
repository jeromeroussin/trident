// Copyright 2022 NetApp, Inc. All Rights Reserved.

package utils

import (
	"errors"
	"fmt"
	"strings"
)

// ///////////////////////////////////////////////////////////////////////////
// bootstrapError
// ///////////////////////////////////////////////////////////////////////////

type bootstrapError struct {
	message string
}

func (e *bootstrapError) Error() string { return e.message }

// BootstrapError is a wrapper for errors that occur during Trident bootstrap.
// It returns a string that can be used to display the error to the user.
// Parameters:
//    err - the error that occurred
// Returns:
//    error - the bootstrap error
// Example:
//    err := utils.BootstrapError(err)
//    log.WithFields(log.Fields{
//        "error": err.Error(),
//    }).Error("Trident initialization failed.")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func BootstrapError(err error) error {
	return &bootstrapError{
		fmt.Sprintf("Trident initialization failed; %s", err.Error()),
	}
}

// IsBootstrapError returns true if the error is a bootstrap error
// Parameters:
//   err: error
// Returns:
//   bool
// Example:
//   if utils.IsBootstrapError(err) {
//       log.Error("Bootstrap error")
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsBootstrapError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*bootstrapError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// foundError
// ///////////////////////////////////////////////////////////////////////////

type foundError struct {
	message string
}

func (e *foundError) Error() string { return e.message }

// FoundError is a custom error
// It returns a string message
// Parameters:
//    message string
// Returns:
//    error
// Example:
//    if err := FoundError("not found"); err != nil {
//       fmt.Println(err)
//    }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func FoundError(message string) error {
	return &foundError{message}
}

// IsFoundError returns true if the error is a foundError
// Parameters:
//   err - error to check
// Returns:
//   true if the error is a foundError
// Example:
//   foundError := IsFoundError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsFoundError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*foundError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// notFoundError
// ///////////////////////////////////////////////////////////////////////////

type notFoundError struct {
	message string
}

func (e *notFoundError) Error() string { return e.message }

// NotFoundError is a custom error
// It returns a 404 error
// Parameters:
//    message (string) - the error message
// Returns:
//    error - the error
// Example:
//    err := utils.NotFoundError("The resource could not be found")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func NotFoundError(message string) error {
	return &notFoundError{message}
}

// IsNotFoundError returns true if the error is a not found error.
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is a not found error
// Example:
//   IsNotFoundError(fmt.Errorf("not found"))
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*notFoundError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// resourceNotFoundError - To identify external not found errors
// ///////////////////////////////////////////////////////////////////////////

// IsResourceNotFoundError returns true if the error is a resource not found error.
// Parameters:
//     err: the error to check
// Return:
//     true if the error is a resource not found error, false otherwise
// Example:
//     if IsResourceNotFoundError(err) {
//         // handle resource not found error
//     }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsResourceNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	return strings.Contains(strings.ToLower(err.Error()), "not found")
}

// ///////////////////////////////////////////////////////////////////////////
// notReadyError
// ///////////////////////////////////////////////////////////////////////////

type notReadyError struct {
	message string
}

func (e *notReadyError) Error() string { return e.message }

// NotReadyError is an error
// It returns a string that Trident is initializing, please try again later
// Returns:
//   *notReadyError
// Example:
//   if err := utils.NotReadyError(); err != nil {
//       fmt.Println(err.Error())
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func NotReadyError() error {
	return &notReadyError{
		"Trident is initializing, please try again later",
	}
}

// IsNotReadyError returns true if the error is a not ready error
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a not ready error, false otherwise
// Example:
//   err := utils.IsNotReadyError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsNotReadyError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*notReadyError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedError struct {
	message string
}

func (e *unsupportedError) Error() string { return e.message }

// UnsupportedError is an error that is returned when a feature is not supported
// It returns a message that can be displayed to the user
// Parameters:
//    message - the message to be displayed
// Returns:
//    error - the error object
// Example:
//    err := UnsupportedError("Snapshot creation is not supported on this storage driver")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func UnsupportedError(message string) error {
	return &unsupportedError{message}
}

// IsUnsupportedError returns true if the error is an unsupportedError
// Parameters:
//    err - error to check
// Returns:
//    true if the error is an unsupportedError
// Example:
//    if IsUnsupportedError(err) {
//       // handle unsupported error
//    }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsUnsupportedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// volumeCreatingError
// ///////////////////////////////////////////////////////////////////////////

type volumeCreatingError struct {
	message string
}

func (e *volumeCreatingError) Error() string { return e.message }

// VolumeCreatingError is returned when a volume is being created
// It returns a message that can be used to describe the error
// Parameters:
//    message: the message to be returned
// Returns:
//    error: an error object
// Example:
//    err := utils.VolumeCreatingError("Error creating volume")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func VolumeCreatingError(message string) error {
	return &volumeCreatingError{message}
}

// IsVolumeCreatingError returns true if the error is a volumeCreatingError
// Parameters:
//    err - error to check
// Returns:
//    true if the error is a volumeCreatingError
// Example:
//    utils.IsVolumeCreatingError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsVolumeCreatingError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*volumeCreatingError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// volumeDeletingError
// ///////////////////////////////////////////////////////////////////////////

type volumeDeletingError struct {
	message string
}

func (e *volumeDeletingError) Error() string { return e.message }

// VolumeDeletingError is an error
// It returns a message
// Parameters:
//    message: the error message
// Return:
//    error
// Example:
//    err := utils.VolumeDeletingError("volume deleting error")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func VolumeDeletingError(message string) error {
	return &volumeDeletingError{message}
}

// IsVolumeDeletingError returns true if the error is a volumeDeletingError
// Parameters:
//    err: error to check
// Return:
//    true if the error is a volumeDeletingError
// Example:
//    if IsVolumeDeletingError(err) {
//      // do something
//    }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsVolumeDeletingError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*volumeDeletingError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// timeoutError
// ///////////////////////////////////////////////////////////////////////////

type timeoutError struct {
	message string
}

func (e *timeoutError) Error() string { return e.message }

// TimeoutError is a custom error
// It returns a string with the error message
// Parameters:
//    message - error message
// Returns:
//    error - error object
// Example:
//    err := utils.TimeoutError("error message")
//    if err != nil {
//        fmt.Println(err)
//    }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func TimeoutError(message string) error {
	return &timeoutError{message}
}

// IsTimeoutError returns true if the error is a timeout error
// Parameters:
//   err: error
// Returns:
//   bool
// Example:
//   if IsTimeoutError(err) {
//		...
//	 }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsTimeoutError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*timeoutError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedKubernetesVersionError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedKubernetesVersionError struct {
	message string
}

func (e *unsupportedKubernetesVersionError) Error() string { return e.message }

// UnsupportedKubernetesVersionError is an error that is returned when the Kubernetes version is not supported
// It returns a message that includes the original error message
// Parameters:
//   err - the original error message
// Returns:
//   an error that includes the original error message
// Example:
//   err := utils.UnsupportedKubernetesVersionError(errors.New("unsupported Kubernetes version"))
//   fmt.Println(err.Error())
//   // Output: unsupported Kubernetes version; unsupported Kubernetes version
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func UnsupportedKubernetesVersionError(err error) error {
	return &unsupportedKubernetesVersionError{
		message: fmt.Sprintf("unsupported Kubernetes version; %s", err.Error()),
	}
}

// IsUnsupportedKubernetesVersionError returns true if the error is an unsupportedKubernetesVersionError
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an unsupportedKubernetesVersionError
// Example:
//   if utils.IsUnsupportedKubernetesVersionError(err) {
//       // error is an unsupportedKubernetesVersionError
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsUnsupportedKubernetesVersionError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedKubernetesVersionError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileDeferredError
// ///////////////////////////////////////////////////////////////////////////

type reconcileDeferredError struct {
	message string
}

func (e *reconcileDeferredError) Error() string { return e.message }

// ReconcileDeferredError is a special error
// It returns a special error that can be used to defer reconciliation
// Parameters:
//    err - error message
// Returns:
//    error - error object
// Example:
//    err := ReconcileDeferredError(errors.New("deferred"))
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func ReconcileDeferredError(err error) error {
	return &reconcileDeferredError{
		message: err.Error(),
	}
}

// IsReconcileDeferredError returns true if the error is a ReconcileDeferredError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a ReconcileDeferredError
// Example:
//   if utils.IsReconcileDeferredError(err) {
//       // do something
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsReconcileDeferredError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileDeferredError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileIncompleteError
// ///////////////////////////////////////////////////////////////////////////

type reconcileIncompleteError struct {
	message string
}

func (e *reconcileIncompleteError) Error() string { return e.message }

// ReconcileIncompleteError is an error that indicates that the reconcile is incomplete
// It returns true for IsReconcileIncompleteError
// Returns:
//   true
// Example:
//   err := ReconcileIncompleteError()
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func ReconcileIncompleteError() error {
	return &reconcileIncompleteError{
		message: "reconcile incomplete",
	}
}

// ConvertToReconcileIncompleteError returns a new error that indicates the reconcile is incomplete
// Parameters:
//   err - the original error
// Returns:
//   a new error that indicates the reconcile is incomplete
// Example:
//   err := errors.New("Incomplete")
//   newErr := ConvertToReconcileIncompleteError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func ConvertToReconcileIncompleteError(err error) error {
	return &reconcileIncompleteError{
		message: err.Error(),
	}
}

// IsReconcileIncompleteError returns true if the error is a reconcileIncompleteError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a reconcileIncompleteError, false otherwise
// Example:
//   err := errors.New("error")
//   IsReconcileIncompleteError(err) // false
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsReconcileIncompleteError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileIncompleteError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// reconcileFailedError
// ///////////////////////////////////////////////////////////////////////////

type reconcileFailedError struct {
	message string
}

func (e *reconcileFailedError) Error() string { return e.message }

// ReconcileFailedError is an error
// It returns a string with the error message
// Parameters:
//   err: the error message
// Returns:
//   error: the error
// Example:
//   err := utils.ReconcileFailedError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func ReconcileFailedError(err error) error {
	return &reconcileFailedError{
		message: fmt.Sprintf("reconcile failed; %s", err.Error()),
	}
}

// IsReconcileFailedError returns true if the error is a reconcileFailedError
// Parameters:
//   err: error to check
// Returns:
//   true if the error is a reconcileFailedError
// Example:
//   if IsReconcileFailedError(err) {
//       // handle error
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsReconcileFailedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*reconcileFailedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedConfigError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedConfigError struct {
	message string
}

func (e *unsupportedConfigError) Error() string { return e.message }

// UnsupportedConfigError returns an error indicating that the supplied configuration is not supported
// Parameters:
//    err - the error that caused the configuration to be unsupported
// Returns:
//    error - an error indicating that the supplied configuration is not supported
// Example:
//    err := utils.UnsupportedConfigError(fmt.Errorf("unsupported feature"))
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func UnsupportedConfigError(err error) error {
	return &unsupportedConfigError{
		message: fmt.Sprintf("unsupported configuration; %s", err.Error()),
	}
}

// IsUnsupportedConfigError returns true if the error is an unsupportedConfigError.
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an unsupportedConfigError, false otherwise
// Example:
//   IsUnsupportedConfigError(errors.New("unsupported config"))
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsUnsupportedConfigError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*unsupportedConfigError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// tempOperatorError
// ///////////////////////////////////////////////////////////////////////////

type tempOperatorError struct {
	message string
}

func (e *tempOperatorError) Error() string { return e.message }

// TempOperatorError is a temporary error that should be retried
// It returns a temporary error that should be retried
// Parameters:
//   err: the error to wrap
// Returns:
//   a temporary error that should be retried
// Example:
//   if err := doSomething(); err != nil {
//       return utils.TempOperatorError(err)
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func TempOperatorError(err error) error {
	return &tempOperatorError{
		message: fmt.Sprintf("temporary operator error; %s", err.Error()),
	}
}

// IsTempOperatorError returns true if the error is a temporary operator error
// Parameters:
//   err - error to check
// Returns:
//   true if the error is a temporary operator error
// Example:
//   if utils.IsTempOperatorError(err) {
//       // handle temporary operator error
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsTempOperatorError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*tempOperatorError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// invalidInputError
// ///////////////////////////////////////////////////////////////////////////

type invalidInputError struct {
	message string
}

func (e *invalidInputError) Error() string { return e.message }

// InvalidInputError is a custom error
// It returns a message
// Parameters:
//    message: string
// Returns:
//    error
// Example:
//    err := utils.InvalidInputError("This is an error")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func InvalidInputError(message string) error {
	return &invalidInputError{message}
}

// IsInvalidInputError returns true if the error is an invalid input error
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is an invalid input error
// Example:
//   if IsInvalidInputError(err) {
//       // err was an invalid input error
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsInvalidInputError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*invalidInputError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// unsupportedCapacityRangeError
// ///////////////////////////////////////////////////////////////////////////

type unsupportedCapacityRangeError struct {
	err     error
	message string
}

func (e *unsupportedCapacityRangeError) Unwrap() error { return e.err }

func (e *unsupportedCapacityRangeError) Error() string { return e.message }

// UnsupportedCapacityRangeError is an error that is returned when a capacity
// range is not supported by the storage driver.
// It returns an error with the message:
// "unsupported capacity range; <error message>"
// Parameters:
//    err - the error message
// Returns:
//    an error
// Example:
//    err := UnsupportedCapacityRangeError(errors.New("invalid capacity range"))
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func UnsupportedCapacityRangeError(err error) error {
	return &unsupportedCapacityRangeError{
		err, fmt.Sprintf("unsupported capacity range; %s",
			err.Error()),
	}
}

// HasUnsupportedCapacityRangeError returns true if the error is an unsupportedCapacityRangeError
// Parameters:
//    err - the error to check
// Returns:
//    bool - true if the error is an unsupportedCapacityRangeError
//    *unsupportedCapacityRangeError - the error if it is an unsupportedCapacityRangeError, nil otherwise
// Example:
//    _, ok := HasUnsupportedCapacityRangeError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func HasUnsupportedCapacityRangeError(err error) (bool, *unsupportedCapacityRangeError) {
	if err == nil {
		return false, nil
	}
	var unsupportedCapacityRangeErrorPtr *unsupportedCapacityRangeError
	ok := errors.As(err, &unsupportedCapacityRangeErrorPtr)
	return ok, unsupportedCapacityRangeErrorPtr
}

// ///////////////////////////////////////////////////////////////////////////
// maxLimitReachedError
// ///////////////////////////////////////////////////////////////////////////

type maxLimitReachedError struct {
	message string
}

func (e *maxLimitReachedError) Error() string { return e.message }

// MaxLimitReachedError is an error that is returned when the maximum limit for a resource has been reached
// It returns a string message
// Parameters:
//    message - the error message
// Returns:
//    error - the error
// Example:
//    if err := utils.MaxLimitReachedError("Maximum limit of volumes has been reached"); err != nil {
//   		log.Errorf("Error: %v\n", err)
//   		return
//    }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func MaxLimitReachedError(message string) error {
	return &maxLimitReachedError{message}
}

// IsMaxLimitReachedError returns true if the error is a maxLimitReachedError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a maxLimitReachedError
// Example:
//   result := utils.IsMaxLimitReachedError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsMaxLimitReachedError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*maxLimitReachedError)
	return ok
}

// ///////////////////////////////////////////////////////////////////////////
// typeAssertionError
// ///////////////////////////////////////////////////////////////////////////

type typeAssertionError struct {
	assertion string
}

// Error returned when a
// It returns a string representation of the assertion that failed.
// Returns:
//   string representation of the assertion that failed
// Example:
//   err := utils.TypeAssertionError{assertion: "slice"}
//   fmt.Println(err.Error())
// Output:
//   could not perform assertion: slice
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func (e *typeAssertionError) Error() string {
	return fmt.Sprintf("could not perform assertion: %s", e.assertion)
}

// TypeAssertionError is a
// It returns an error with the given assertion string.
// Parameters:
//   assertion: the assertion string
// Returns:
//   an error with the given assertion string
// Example:
//   err := utils.TypeAssertionError("a.b.c")
//   fmt.Printf("%v", err)
//   // Output:
//   // Type assertion error: a.b.c
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func TypeAssertionError(assertion string) error {
	return &typeAssertionError{assertion}
}

// ///////////////////////////////////////////////////////////////////////////
// authError
// ///////////////////////////////////////////////////////////////////////////

type authError struct {
	message string
}

func (e *authError) Error() string { return e.message }

// AuthError is an error that can be returned from the auth package
// It returns a message that can be displayed to the user
// Parameters:
//   message (string) - the message to display to the user
// Returns:
//   error - an error that can be returned from the auth package
// Example:
//   err := auth.AuthError("There was an error authenticating")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func AuthError(message string) error {
	return &authError{message}
}

// IsAuthError returns true if the error is an auth error
// Parameters:
//   err: the error to check
// Returns:
//   true if the error is an auth error
// Example:
//   IsAuthError(err)
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsAuthError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*authError)
	return ok
}

/////////////////////////////////////////////////////////////////////////////
// tooManyRequestsError (HTTP 429)
/////////////////////////////////////////////////////////////////////////////

type tooManyRequestsError struct {
	message string
}

func (e *tooManyRequestsError) Error() string { return e.message }

// TooManyRequestsError is an error that indicates that the client has sent too many requests in a given amount of time.
// It returns a 429 status code.
// Parameters:
//    message: the error message
// Returns:
//    an error
// Example:
//    err := utils.TooManyRequestsError("Too many requests")
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func TooManyRequestsError(message string) error {
	return &tooManyRequestsError{message}
}

// IsTooManyRequestsError returns true if the error is a TooManyRequestsError
// Parameters:
//   err - the error to check
// Returns:
//   true if the error is a TooManyRequestsError, false otherwise
// Example:
//   if utils.IsTooManyRequestsError(err) {
//       // handle error
//   }
//
// -- Doc autogenerated on 2022-05-12 16:29:59.146129 --
func IsTooManyRequestsError(err error) bool {
	if err == nil {
		return false
	}
	_, ok := err.(*tooManyRequestsError)
	return ok
}
